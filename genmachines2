#!/bin/env python

from string import split, strip, find
from sys import argv, exit
from os import popen, getenv
from glob import glob
import socket
import struct
from xml.parsers import expat


program = 'genmachines'
author  = 'Walter Brisken'
version = '0.7'
verdate = '20080114'

mk5list = 'mk5list'

def usage():
	print '\n%s ver. %s  %s %s' % (program, version, author, verdate)
	print '\nA program to find required Mark5 modules and write the machines file'
	print 'appropriate for a particular DiFX job.'
	print '\nUsage : %s [options] <input 1> [<input 2> [ ... ] ]' % argv[0]
	print '\noptions can include:'
	print '\n  -h or --help'
	print '          print this usage info and exit'
	print '\n  -v or --verbose'
	print '          increase verbosity of output'
	print '\n  -o or --overheadcores <ohc>'
	print '          set overheadcores to <ohc>, default = 1'
	print '\n  -m <machinesfile> or --machines <machinesfile>'
	print '          use <machinesfile> instead of $DIFX_MACHINES'
	print '\n<input> is a DiFX .input file.  If multiple files are provided, each is'
	print '    processed individually to produce its own .machines file.'
	print '\nEnv. Var. DIFX_MACHINES must point to the machines file if no <machinesfile>'
	print 'is specifided.\n'
	exit(1)

class Parser:

    def __init__(self):
        self._parser = expat.ParserCreate()
        self._parser.StartElementHandler = self.start
        self._parser.EndElementHandler = self.end
        self._parser.CharacterDataHandler = self.data
	self.vsnA = 'none'
	self.vsnB = 'none'
	self.state = 'Unknown'
	self.unit = 'unknown'
	self.tmp = ''

    def feed(self, data):
        self._parser.Parse(data, 0)

    def close(self):
        self._parser.Parse("", 1) # end of data
        del self._parser # get rid of circular references

    def start(self, tag, attrs):
        pass

    def end(self, tag):
        if tag == 'bankAVSN':
		self.vsnA = self.tmp
        if tag == 'bankBVSN':
		self.vsnB = self.tmp
	if tag == 'from':
		self.unit = self.tmp
	if tag == 'state':
		self.state = self.tmp

    def data(self, data):
        self.tmp = data

    def getinfo(self):
        return [self.unit, self.vsnA, self.vsnB, self.state]

def getmodules(maxtime):
	dt = 0.2
	t = 0.0
	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
	sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
	sock.sendto("VSN?", ("224.2.2.1", 50201))

	s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	#s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
	s.bind(('', 50200))
	mreq = struct.pack("4sl", socket.inet_aton("224.2.2.1"), socket.INADDR_ANY)
	s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
	s.settimeout(dt)
	conflicts = []
	results = []
	while t < maxtime:
		try:
			message = s.recv(1024)
			print message
			p = Parser()
			p.feed(message)
			info = p.getinfo()
			results.append(info)
			p.close()

		except socket.timeout:
			t += dt

	return results

def getvsns(inputfile):
	vsns = []
	nds = 0
	input = open(inputfile).readlines()
	for i in input:
		if i[0:18] == 'ACTIVE DATASTREAMS':
			s = split(i, ':')
			if len(s) == 2:
				nds = int(strip(s[1]))
		if i[0:5] == 'FILE ':
			s = split(i, '/')
			ds = int(strip(s[0][5:]))
			if ds < nds:
				s = split(i, ':')
				if len(s) == 2:
					vsns.append(strip(s[1]))
	return vsns

def readmachines(machinesfile, verbose):
	machines = []
	cores = []
	ismk5 = {}
	lines = open(machinesfile).readlines()
	for l in lines:
		l = split(strip(l), '#')[0]
		s = split(l)
		if len(s) >= 2:
			machines.append(s[0])
			cores.append(int(s[1]))
			if len(s) >= 3:
				ismk5[s[0]] = int(s[2])
			else:
				if s[0][:5] == 'mark5':
					ismk5[s[0]] = 1
				else:
					ismk5[s[0]] = 0
	if verbose > 0:
		print 'MACHINES = ', machines
		print 'CORES    = ', cores
		print 'IS MK5   = ', ismk5

	return machines,cores,ismk5

def gethostname():
	o = popen('hostname', 'r')
	host = strip(o.readline())
	o.close()
	return host

def writethreads(basename, threads):
	o = open(basename+'threads', 'w')
	o.write('NUMBER OF CORES:    %d\n' % len(threads))
	for t in threads:
		o.write('%d\n' % t)
	o.close()

def conflict(nodes):
	if len(nodes) < 2:
		return False
	L = []
	for n in nodes:
		L.append(n)
	L.sort()
	for i in range(1, len(L)):
		if L[i-1] == L[i]:
			return True;
	return False

def writemachines(basename, hostname, machines, cores, results, vsns, \
	overheadcores, verbose):
	dsnodes = []
	threads = []
	extrathreads = []
	quit = False
	for v in vsns:
		ok = 0
		units in results.keys()
		units.sort()
		for u in units
			r = results[u]
			print r
			if r[1] == v or r[2] == v:
				dsnodes.append(r[0])
				ok = 1
		if ok == 0:
			print 'module %s not found!' % v
			quit = True

	if conflict(dsnodes):
		print 'resource conflict'
		quit = True

	if quit:
		print 'genmachines quitting.'
		return []

	# write file
	o = open(basename+'machines', 'w')
	# head node
	maxslots = 1
	if hostname in machines:
		m = machines.index(hostname)
		if cores[m] > overheadcores+1:
			maxslots = 2
			extrathreads.append(cores[m] - (overheadcores+1))
	o.write('%s slots=1 max-slots=%d\n' % \
		(hostname, maxslots))
	# datastream nodes
	for d in dsnodes:
		m = machines.index(d)
		if cores[m] > overheadcores+1:
			maxslots = 2
			extrathreads.append(cores[m] - (overheadcores+1))
		else:
			maxslots = 1
		o.write('%s slots=1 max-slots=%d\n' % \
			(d, maxslots))
	# core nodes
	for m in range(len(machines)):
		if machines[m] in dsnodes:
			continue
		if cores[m] < 1:
			continue
		threads.append(cores[m])
		o.write('%s slots=1 max-slots=1\n' % machines[m])
	o.close()
	for e in extrathreads:
		threads.append(e)
	return threads

def run(files, machinesfile, overheadcores, verbose):
	machines,cores,ismk5 = readmachines(machinesfile, verbose)

	hostname = gethostname()
	if not hostname in machines:
		print 'ERROR: hostname not in machines file : %s' % machinesfile
		exit(1)

	#qresults = mk5query(machines, ismk5)
	qresults = getmodules(5)

	for infile in files:
		results = {}
		for q in qresults:
			if q[3] == 'Idle':
				r = []
				if q[1] != 'none':
					r.append(q[1])
				if q[2] != 'none':
					r.append(q[2])
				results[q[0]] = r

		basename = infile[0:-5]
		if basename + 'input' != infile:
			print 'expecting input file'
			exit(1)
					
		vsns = getvsns(infile)

		t = writemachines(basename, hostname, machines, cores, results, \
			vsns, overheadcores, verbose)
		if len(t) == 0:
			return 1
		writethreads(basename, t)

		results.sort()

		for r in results:
			print r[0], r[1]

	return 0

if len(argv) < 2:
	usage()
else:
	files = []
	machinesfile = getenv('DIFX_MACHINES')
	overheadcores = 1
	verbose = 0
	
	a = 1
	while a < len(argv):
		arg = argv[a]
		if arg == '-h' or arg == '--help':
			usage()
		elif arg == '-v' or arg == '--verbose':
			verbose += 1
		elif arg == '-m' or arg == '--machinesfile':
			a += 1
			if a >= len(argv):
				print 'No machinesfile specified!'
				exit(1)
			machinesfile = argv[a]
		elif arg == '-o' or arg == '--overheadcores':
			a += 1
			if a >= len(argv):
				print 'No overhead cores specified1'
				exit(1)
			overheadcores = int(argv[a])
		else:
			files.append(arg)
		a += 1

	if len(files) < 1:
		usage()

	quit = False
	for f in files:
		if len(glob(f)) != 1:
			print 'File %s not found' % f
			quit = True
		
	if machinesfile == None:
		print 'DIFX_MACHINES env var not defined!';
		quit = True

	if len(glob(machinesfile)) != 1:
		print 'Machinesfile %s not found.' % machinesfile
		quit = True
		
	if quit:
		print 'genmachines quitting.'
		exit(1)
		
	v = run(files, machinesfile, overheadcores, verbose)
	if v != 0:
		exit(v)
