#!/bin/env python

from string import split, strip, find, upper, lower
from sys import argv, exit
from os import popen, getenv
from glob import glob
import socket
import struct
from xml.parsers import expat
from copy import deepcopy


program = 'genmachines2'
author  = 'Walter Brisken'
version = '0.8'
verdate = '20080521'

defaultDifxMessagePort = 50200
defaultDifxMessageGroup = '224.2.2.1'


def usage():
	print '\n%s ver. %s  %s %s' % (program, version, author, verdate)
	print '\nA program to find required Mark5 modules and write the machines file'
	print 'appropriate for a particular DiFX job.'
	print '\nUsage : %s [options] <input>' % argv[0]
	print '\noptions can include:'
	print '\n  -h or --help'
	print '          print this usage info and exit'
	print '\n  -v or --verbose'
	print '          increase verbosity of output'
	print '\n  -o or --overheadcores <ohc>'
	print '          set overheadcores to <ohc>, default = 1'
	print '\n  -m <machinesfile> or --machines <machinesfile>'
	print '          use <machinesfile> instead of $DIFX_MACHINES'
	print '\n<input> is a DiFX .input file.'
	print '\nEnv. Var. DIFX_MACHINES must point to the machines file if no <machinesfile>'
	print 'is specifided.\n'
	exit(1)

class Parser:

    def __init__(self):
        self._parser = expat.ParserCreate()
        self._parser.StartElementHandler = self.start
        self._parser.EndElementHandler = self.end
        self._parser.CharacterDataHandler = self.data
	self.vsnA = 'none'
	self.vsnB = 'none'
	self.state = 'Unknown'
	self.unit = 'unknown'
	self.tmp = ''
	self.ok = False

    def feed(self, data):
        self._parser.Parse(data, 0)

    def close(self):
        self._parser.Parse("", 1) # end of data
        del self._parser # get rid of circular references

    def start(self, tag, attrs):
        if tag == 'mark5Status':
		self.ok = True

    def end(self, tag):
        if tag == 'bankAVSN' and self.ok:
		if len(self.tmp) != 8:
			self.vsnA = 'none'
		else:
			self.vsnA = upper(self.tmp)
        if tag == 'bankBVSN' and self.ok:
		if len(self.tmp) != 8:
			self.vsnB = 'none'
		else:
			self.vsnB = upper(self.tmp)
	if tag == 'from':
		self.unit = lower(self.tmp)
	if tag == 'state' and self.ok:
		self.state = self.tmp

    def data(self, data):
        self.tmp = data

    def getinfo(self):
	if self.ok:
        	return [self.unit, self.vsnA, self.vsnB, self.state]
	else:
		return ['unknown', 'none', 'none', 'Unknown']

def vsn_request():
	src = socket.gethostname()
	dest = '<to>mark5</to>'
	cmd = 'getvsn'

	message = \
	  '<?xml version="1.0" encoding="UTF-8"?>\n' \
	  '<difxMessage>' \
	    '<header>' \
	      '<from>%s</from>' \
	      '%s' \
	      '<mpiProcessId>-1</mpiProcessId>' \
	      '<identifier>mk5control</identifier>' \
	      '<type>DifxCommand</type>' \
	    '</header>' \
	    '<body>' \
	      '<seqNumber>0</seqNumber>' \
	      '<difxCommand>' \
	        '<command>%s</command>' \
	      '</difxCommand>' \
	    '</body>' \
	  '</difxMessage>' % (src, dest, cmd)

	return message

def getVsnsByMulticast(maxtime, modlist, verbose):
	dt = 0.2
	t = 0.0

	port = getenv('DIFX_MESSAGE_PORT')
	if port == None:
		port = defaultDifxMessagePort
	else:
		port = int(port)
	group = getenv('DIFX_MESSAGE_GROUP')
	if group == None:
		group = defaultDifxMessageGroup

	missing = deepcopy(modlist)

	message = vsn_request()

	# First send out a call for VSNs
	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
	sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
	sock.sendto(message, (group, port))

	# Now listen for responses, until either time runs out or we get all we need
	s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	s.bind(('', port))
	mreq = struct.pack("4sl", socket.inet_aton(group), socket.INADDR_ANY)
	s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
	s.settimeout(dt)
	conflicts = []
	results = []
	machines = []
	while t < maxtime:
		try:
			message = s.recv(1024)
			if verbose > 1:
				print message
			p = Parser()
			p.feed(message)
			info = p.getinfo()
			p.close()
			if info[0] == 'unknown':
				continue
			if info[0] in machines:
				continue
			machines.append(info[0])
			results.append(info)
			if info[1] in missing and info[2] in missing:
				conflicts.append(info)
			if info[1] in missing:
				missing.remove(info[1])
			if info[2] in missing:
				missing.remove(info[2])

		except socket.timeout:
			t += dt

	results.sort()
	conflicts.sort()
	missing.sort()

	return results, conflicts, missing

def getVsnsFromInputFile(inputfile):
	vsns = []
	nds = 0
	input = open(inputfile).readlines()
	for i in input:
		if i[0:18] == 'ACTIVE DATASTREAMS':
			s = split(i, ':')
			if len(s) == 2:
				nds = int(strip(s[1]))
		if i[0:5] == 'FILE ':
			s = split(i, '/')
			ds = int(strip(s[0][5:]))
			if ds < nds:
				s = split(i, ':')
				if len(s) == 2:
					vsns.append(strip(s[1]))
	return vsns

def readmachines(machinesfile, verbose):
	machines = []
	cores = []
	ismk5 = {}
	lines = open(machinesfile).readlines()
	for l in lines:
		l = split(strip(l), '#')[0]
		s = split(l)
		if len(s) >= 2:
			machines.append(s[0])
			cores.append(int(s[1]))
			if len(s) >= 3:
				ismk5[s[0]] = int(s[2])
			else:
				if s[0][:5] == 'mark5':
					ismk5[s[0]] = 1
				else:
					ismk5[s[0]] = 0
	if verbose > 1:
		print 'MACHINES = ', machines
		print 'CORES    = ', cores
		print 'IS MK5   = ', ismk5

	return machines,cores,ismk5

def writethreads(basename, threads):
	o = open(basename+'threads', 'w')
	o.write('NUMBER OF CORES:    %d\n' % len(threads))
	for t in threads:
		o.write('%d\n' % t)
	o.close()

def writemachines(basename, hostname, machines, cores, results, vsns, \
	overheadcores, verbose):
	dsnodes = []
	threads = []
	extrathreads = []
	quit = False
	for v in vsns:
		for r in results:
			if r[1] == v or r[2] == v:
				dsnodes.append(r[0])
	
	for d in dsnodes:
		if not d in machines:
			print '%s not enabled in machines file' % d
			quit = True

	if quit:
		return []

	# write file
	o = open(basename+'machines', 'w')
	# head node
	maxslots = 1
	if hostname in machines:
		m = machines.index(hostname)
		if cores[m] > overheadcores+1:
			maxslots = 2
			extrathreads.append(cores[m] - (overheadcores+1))
	o.write('%s slots=1 max-slots=%d\n' % \
		(hostname, maxslots))
	# datastream nodes
	for d in dsnodes:
		m = machines.index(d)
		if cores[m] > overheadcores+1:
			maxslots = 2
			extrathreads.append(cores[m] - (overheadcores+1))
		else:
			maxslots = 1
		o.write('%s slots=1 max-slots=%d\n' % \
			(d, maxslots))
	# core nodes
	for m in range(len(machines)):
		if machines[m] in dsnodes:
			continue
		if cores[m] < 1:
			continue
		threads.append(cores[m])
		o.write('%s slots=1 max-slots=1\n' % machines[m])
	o.close()
	for e in extrathreads:
		threads.append(e)
	return threads

def run(files, machinesfile, overheadcores, verbose):
	ok = True

	machines, cores, ismk5 = readmachines(machinesfile, verbose)

	hostname = socket.gethostname()
	if not hostname in machines:
		print 'ERROR: hostname not in machines file : %s' % machinesfile
		exit(1)

	infile = files[0]

	basename = infile[0:-5]
	if basename + 'input' != infile:
		print 'expecting input file'
		exit(1)
				
	vsns = getVsnsFromInputFile(infile)

	results, conflicts, missing = getVsnsByMulticast(5, vsns, verbose)

	if verbose > 0:
		print 'Found modules:'
		for r in results:
			print '  %-10s : %10s %10s   %s' % (r[0], r[1], r[2], r[3])

	if len(conflicts) > 0:
		ok = False
		print 'Module conflicts:'
		for c in conflicts:
			print '  %-10s : %10s %10s' % (c[0], c[1], c[2])
	
	if len(missing) > 0:
		ok = False
		print 'Missing modules:'
		for m in missing:
			print '  %s' % m

	if not ok:
		return 1

	t = writemachines(basename, hostname, machines, cores, results, \
		vsns, overheadcores, verbose)

	if len(t) == 0:
		return 1

	writethreads(basename, t)

	return 0

if len(argv) < 2:
	usage()

files = []
machinesfile = getenv('DIFX_MACHINES')
overheadcores = 1
verbose = 0

a = 1
while a < len(argv):
	arg = argv[a]
	if arg == '-h' or arg == '--help':
		usage()
	elif arg == '-v' or arg == '--verbose':
		verbose += 1
	elif arg == '-m' or arg == '--machinesfile':
		a += 1
		if a >= len(argv):
			print 'No machinesfile specified!'
			exit(1)
		machinesfile = argv[a]
	elif arg == '-o' or arg == '--overheadcores':
		a += 1
		if a >= len(argv):
			print 'No overhead cores specified1'
			exit(1)
		overheadcores = int(argv[a])
	else:
		files.append(arg)
	a += 1

if len(files) != 1:
	usage()

quit = False
for f in files:
	if len(glob(f)) != 1:
		print 'File %s not found' % f
		quit = True
	
if machinesfile == None:
	print 'DIFX_MACHINES env var not defined!';
	quit = True

elif len(glob(machinesfile)) != 1:
	print 'Machinesfile %s not found.' % machinesfile
	quit = True
	
if quit:
	print 'genmachines quitting.'
	exit(1)

if verbose > 0:
	print 'DIFX_MACHINES -> %s' % machinesfile
	
v = run(files, machinesfile, overheadcores, verbose)
if v != 0:
	exit(v)
