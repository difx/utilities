#!/usr/bin/env python

import datetime
import cx_Oracle
from sys import argv, exit
from os import getenv, popen, umask
from os.path import isfile
from string import upper, lower, strip, split

program = 'db2vex'
author = 'Walter Brisken'
version = '0.6'
verdate = '20101019'

databaseName = getenv("VLBA_DB")

mjd0 = datetime.datetime(1858, 11, 17, 0, 0)

def usage(pgm):
	print '%s ver %s  %s  %s\n' % (program, version, author, verdate)
	print 'A program to append monitor data to a vex file for software correlation.\n'
	print 'Usage: %s [options] <vex file> [<fslog>] [<fslog>] ...\n' % pgm
	print 'options can be:\n'
	print '  --help'
	print '  -h         print this message and quit\n'
	print '  --verbose'
	print '  -v         print more diagnostics to screen\n'
	print '  --force'
	print '  -f         run even if means overwriting exisiting files\n'
	print '  --vsnProjectCode  <project code>'
	print '             use provided project code in VSN DB queries\n'
	print '<vex file> is a vex file produced by sched (usually ending in .skd)\n'
	print '<fslog> is a field system log file\n'
	print 'Example:  db2vex bj061h.skd\n'
	exit(0)

# Splits a combined obs code into its proposal and segment portions

def splitobscode(exper):
	obsSeg = ''
	proposal = exper[:]

	if len(proposal) > 3:
		if proposal[0].isalpha() and proposal[1].isalpha() and proposal[2].isdigit():
			for i in range(3, len(proposal)):
				if proposal[i].isalpha():
					obsSeg = proposal[i:]
					proposal = proposal[0:i]
					break
		if proposal[0].isalpha() and proposal[1].isdigit():
			for i in range(2, len(proposal)):
				if proposal[i].isalpha():
					obsSeg = proposal[i:]
					proposal = proposal[0:i]
					break
	
	return proposal, obsSeg

def vexPeek(vexFile, verbose):
	
	cmd = 'vexpeek %s' % vexFile
	if verbose > 0:
		print 'Executing command: %s' % cmd

	p = popen(cmd)
	data = p.readlines()

	if len(data) == 0:
		return 'Error', 'Error', 'Error'
	
	obsCode = upper(strip(data[0]))
	obsSeg = ''

	if obsCode[0:5] == 'ERROR':
		return 'Error', 'Error', 'Error'

	if len(obsCode) > 3:
		if obsCode[0].isalpha() and obsCode[1].isalpha() and obsCode[2].isdigit():
			for i in range(3, len(obsCode)):
				if obsCode[i].isalpha():
					obsSeg = obsCode[i:]
					obsCode = obsCode[0:i]
					break;
		if obsCode[0].isalpha() and obsCode[1].isdigit():
			for i in range(2, len(obsCode)):
				if obsCode[i].isalpha():
					obsSeg = obsCode[i:]
					obsCode = obsCode[0:i]
					break;
		

	stationTimes = {}
	for d in data[1:]:
		s = split(strip(d))
		stationTimes[upper(s[0])] = [float(s[1]), float(s[2])]

	print 'This is experiment %s %s' % (obsCode, obsSeg)

	return obsCode, obsSeg, stationTimes

def calcExperTimes(stationTimes):
	start = 1.0e9
	stop = -1.0e9
	keys = stationTimes.keys()
	for key in keys:
		s = stationTimes[key]
		if s[0] < start:
			start = s[0]
		if s[1] > stop:
			stop = s[1]
	return [start, stop]

def mjdCenter(stationTimes):
	start = 1.0e10
	stop = 0.0
	for s in stationTimes:
		a = stationTimes[s][0]
		b = stationTimes[s][1]
		if a < start:
			start = a
		if b > stop:
			stop = b
	return (start + stop)*0.5


def mjd2vex(mjd, dateonly=False):
	md = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
	d = int(mjd)
	s = int((mjd - d)*86400.0 + 0.5)
	dt = datetime.timedelta(d, s)
	t = mjd0 + dt
	d = t.day + md[t.month-1]
	if t.year % 4 == 0 and t.month > 2:
		d += 1
	if dateonly:
		return '%dy%03dd' % (t.year, d)
	else:
		return '%dy%03dd%02dh%02dm%02ds' % (t.year, d, t.hour, t.minute, t.second)

def mjd2date(mjd):
	mon = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
	dt = datetime.timedelta(int(mjd+0.5/86400.0), 0)
	t = mjd0 + dt
	return '%02d-%s-%04d' % (t.day, mon[t.month-1], t.year)

def Ulow(s):
	return upper(s[0]) + lower(s[1:])

def calcMJD(t):
	dt = t - mjd0
	mjd = dt.days + dt.seconds/86400.0
	return mjd

def day2mjd(year, doy):
	NYR = int(year)
	NYRD = int(doy)
	# L2 IS -1 IF LEAP YEAR, -2 IF NOT.
	L2 = NYR/4-(NYR+7)/4-NYR/100+(NYR+99)/100+NYR/400-(NYR+399)/400
	MO = (12*NYRD+356+(NYRD+322)/367*(6-12*L2))/367
	NDA = NYRD-(367*MO-362)/12-(MO+9)/12*L2
	NYR1 = NYR-1
	MJD = NYRD-678576+365*NYR1+NYR1/4-NYR1/100+NYR1/400
	return MJD

def getFSTime(str):
	if str[0:2] != '20':
		return -1.0
	if str[14] != ':':
		return -1.0
	y = int(str[0:4])
	d = int(str[5:8])
	h = int(str[9:11])
	m = int(str[12:14])
	s = float(str[15:20])

	return day2mjd(y, d) + h/24.0 + m/1440.0 + s/86400.0

def oh2zero(x):
	return x.replace('O', '0')

def zero2oh(x):
	y = ""
	before = True
	for i in range(len(x)):
		if before and x[i] == '0':
			y += 'O'
		else:
			y += x[i]
		if x[i] == '+' or x[i] == '-':
			before = False
	return y

def getShelf(shelves, vsn):
	for s in shelves:
		if oh2zero(s[0]) == oh2zero(vsn):
			return s[1]
	return 'none'

def getShelvesFromDB(db, verbose):
	cursor = db.cursor()
	query = "select * from SHELVES"
	if verbose > 0:
		print 'Executing database query: %s' % query
	cursor.execute(query)
	shelves = cursor.fetchall()
	return shelves

def getTapesFromDBbyTime(db, startMJD, stopMJD, verbose):

	# select time range that encompases a bit more than the whole experiment
	# better to be overly inclusive here!
	start = mjd2date(startMJD - 1.0)
	stop  = mjd2date(stopMJD  + 1.0)

	cursor = db.cursor()
	query = "select * from TAPE where EPOCH > '%s' and EPOCH < '%s' order by STAID,EPOCH" % (start, stop)
	if verbose > 0:
		print 'Executing database query: %s' % query
	cursor.execute(query)
	tapes = cursor.fetchall()
	return tapes

def getVSN(vsns, stn, unitNumber, t):
	vsn = 'none'
	if not vsns.has_key(stn):
		return vsn
	for v in vsns[stn]:
		if t + 0.5/86400.0 >= v[0] and unitNumber == v[2]:
			vsn = v[1]
	return vsn

def getTapeMotionFromDB(db, prop, seg, verbose):
	cursor = db.cursor()
	collect = "STAID,TAPESPEED1,TAPESPEED2,START_TIME,STOP_TIME"
	if len(seg) > 0:
		query = "select %s from OBSSTA where PROPOSAL='%s' and SEGMENT='%s' order by START_TIME" % (collect, prop, seg)
	else:
		query = "select %s from OBSSTA where PROPOSAL='%s' order by START_TIME" % (collect, prop)
	if verbose > 0:
		print 'Executing database query: %s' % query
	cursor.execute(query)
	motions = cursor.fetchall()
	return motions

def getClockFromDB(db, stn, timerange, verbose):
	gps_offsets = []
	clocks = []

	cursor = db.cursor()
	query = "select VERSION,GPS_EPOCH,GPS_OFFSET from STATIONS where STN_ID='%s' order by VERSION,GPS_EPOCH" % stn
	if verbose > 0:
		print 'Executing database query: %s' % query
	cursor.execute(query)
	gps_offsets = cursor.fetchall()
	if len(gps_offsets) == 0:
		return []
	gps_offset = gps_offsets[-1][-1]

	cursor = db.cursor()
	query = "select * from CLOCKS where STAID='%s' order by EPOCH_STOP,VERSION" % stn
	if verbose > 0:
		print 'Executing database query: %s' % query
	cursor.execute(query)
	allclocks = cursor.fetchall()
	if len(allclocks) == 0:
		return []
	clocks = []
	for c in allclocks:
		if c[6] == None:
			if calcMJD(c[1]) < 51544.0:
				continue
			else:
				clocks.append(c)
				break;
		mjd = calcMJD(c[6])
		if mjd > timerange[0]:
			clocks.append(c)
			if mjd > timerange[1]:
				break;

	v = []
	start = timerange[0]
	for c in clocks:
		v.append( (start, c[4]+gps_offset, calcMJD(c[1]), c[5], gps_offset*1.0e6) )
		if c[6] != None:
			start = calcMJD(c[6])


	return v

def getEarthFromDBold(db, centerMJD, verbose):
	cursor = db.cursor()
	startMJD = int(centerMJD+0.5) - 2
	stopMJD  = int(centerMJD+0.5) + 2
	eops  = []
	ver = '  * data versions = '
	origin = '  * data origins = '
	ut1_utc = '  ut1-utc  = '
	x_pole  = '  x_wobble = '
	y_pole  = '  y_wobble = '

	eops.append("$EOP;\n")
	eops.append("def EOP%d;\n" % startMJD)

	nPredict = 0;

	for m in range(startMJD, stopMJD+1):
		d  = mjd2date(m)
		query = "select EPOCH,VERSION,ORIGIN,TAI_UTC,UT1_UTC,X_POLE,Y_POLE " \
			"from EARTH where EPOCH = '%s' order by EPOCH,VERSION" % d
		if verbose > 0:
			print 'Executing database query: %s' % query
		cursor.execute(query)
		E = cursor.fetchall()
		if len(E) < 1:
			print 'Error: no EOPs for day %s' % d
		else:
			e = E[-1]	# select most recent
			if m == startMJD:
				eops.append("  TAI-UTC= %d sec;\n" % e[3])
				eops.append("  A1-TAI= 0 sec;\n")
				eops.append("  eop_ref_epoch=%s;\n" % mjd2vex(calcMJD(e[0]), True))
				eops.append("  num_eop_points=5;\n")
				eops.append("  eop_interval=24 hr;\n")
			if m == stopMJD:
				end = ';\n'
			else:
				end = ' : '
			ver = ver + mjd2vex(calcMJD(e[1])) + end
			org = upper(strip(e[2]))
			if org == 'PREDICT':
				nPredict += 1
			origin = origin + org + end
			ut1_utc = ut1_utc + ('%8.6f sec' % e[4]) + end
			x_pole = x_pole + ('%7.5f asec' % e[5]) + end
			y_pole = y_pole + ('%7.5f asec' % e[6]) + end
		
	eops.append(ut1_utc)
	eops.append(x_pole)
	eops.append(y_pole)
	eops.append(ver)
	eops.append(origin)
	eops.append("enddef;\n")

	if nPredict > 0:
		print 'Warning: %d of %d EOP data are PREDICTs' % (nPredict, stopMJD-startMJD+1)

	return eops

def getEarthFromDB(db, centerMJD, verbose):
	cursor = db.cursor()
	startMJD = int(centerMJD+0.5) - 2
	stopMJD  = int(centerMJD+0.5) + 2
	eops  = []
	ver = '  * data versions = '
	origin = '  * data origins = '
	ut1_utc = '  ut1-utc  = '
	x_pole  = '  x_wobble = '
	y_pole  = '  y_wobble = '

	eops.append("$EOP;\n")

	nPredict = 0;

	for m in range(startMJD, stopMJD+1):
		d  = mjd2date(m)
		query = "select EPOCH,VERSION,ORIGIN,TAI_UTC,UT1_UTC,X_POLE,Y_POLE " \
			"from EARTH where EPOCH = '%s' order by EPOCH,VERSION" % d
		if verbose > 0:
			print 'Executing database query: %s' % query
		cursor.execute(query)
		E = cursor.fetchall()
		if len(E) < 1:
			print 'Error: no EOPs for day %s' % d
		else:
			e = E[-1]	# select most recent EOP entry for this day
			origin = upper(strip(e[2]))
			eops.append("def EOP%d_%s;\n" % (m, origin))
			eops.append("  TAI-UTC= %d sec;\n" % e[3])
			eops.append("  A1-TAI= 0 sec;\n")
			eops.append("  eop_ref_epoch=%s;\n" % mjd2vex(calcMJD(e[0]), True))
			eops.append("  num_eop_points=1;\n")
			eops.append("  eop_interval=24 hr;\n")
			eops.append("  ut1-utc  = %8.6f sec;\n" % e[4])
			eops.append("  x_wobble = %7.5f asec;\n" % e[5])
			eops.append("  y_wobble = %7.5f asec;\n" % e[6])
			eops.append("  * data version = %s;\n" % mjd2vex(calcMJD(e[1])))

			if origin == 'PREDICT':
				nPredict += 1
			eops.append("enddef;\n")
		
	if nPredict > 0:
		print 'Warning: %d of %d EOP data are PREDICTs' % (nPredict, stopMJD-startMJD+1)

	return eops
	


def makeVSNDict(tapes):
	td = {}
	for t in tapes:
		stn = t[2]
		mjd = calcMJD(t[3])
		row = [mjd, t[4], t[5]-4]
		if not td.has_key(stn):
			td[stn] = []
		td[stn].append(row)
	return td

def calcVSNList(motions, vsns, stn):
	r = []
	for m in motions:
		if m[0] == stn and (m[1] != 0 or m[2] != 0):
			if m[1] != 0:
				u = 0
			else:
				u = 1
			t1 = calcMJD(m[3])
			t2 = calcMJD(m[4])
			r.append([u, t1, t2, getVSN(vsns, stn, u, t1)])
	return r;

def genBlocks(scans, experTimes):
	blocks = []
	curBlock = [0.0, 0.0, 'none', -1]
	for s in scans:
		if s[1] > experTimes[1] or s[2] < experTimes[0]:
			continue
		if s[3] == curBlock[2]:
			if s[2] > curBlock[1]:
				curBlock[1] = s[2]
			else:
				print 'Warning: not time ordered!', s[3], curBlock[1], s[2]
		else:
			curBlock = [s[1], s[2], s[3], s[0]]
			blocks.append(curBlock);
	return blocks

def writeShelfData(data, fileName):
	out = open(fileName, 'w')
	for d in data:
		out.write('%s %s %s\n' % (d[0], zero2oh(d[1]), d[2]))
	out.close()

def signFlip(clock):
	return (clock[0], -clock[1], clock[2], -clock[3], -clock[4])



def parseFSLog(fn, vsnList):
	vsns = []
	data = open(fn).readlines()
	currentVsn = None
	stationName = None
	for d in data:
		t = getFSTime(d)
		if t < 0.0:
			continue
		if d[21:32] == 'bank_check/':
			v = d[32:40]
			if currentVsn != None:
				if currentVsn[0] == v:
					continue
			currentVsn = [v, 0.0, 0.0]
			vsns.append(currentVsn)
		if d[21:31] == 'scan_name=':
			s = split(strip(d[32:]), ',')
			if stationName == None:
				stationName = s[2]
			elif stationName != s[2]:
				print 'Warning: station names disagree: %s %s' % (s[2], stationName);
		if d[21:35] == 'disk_record=on':
			if currentVsn != None:
				if currentVsn[1] < 1:
					currentVsn[1] = t
			else:
				print 'Warning: disk_record=on but no vsn! %s' % s[0]
		if d[21:36] == 'disk_record=off':
			if currentVsn != None:
				currentVsn[2] = t
			else:
				print 'Warning: disk_record=off but no vsn! %s' % s[0]

	if stationName == None:
		return
	
	stationName = Ulow(stationName)

	for v in vsns:
		if v[1] > 1 and v[2] > 1:
			vsnList.append([stationName, v[0], v[1], v[2]]);

	print '  finished.  Station ID = %s' % stationName


def getBlocksFromFS(fsVSNs, stn):
	rv = []
	for a in fsVSNs:
		if a[0] == stn:
			rv.append([a[2], a[3], a[1], 0])

	return rv

def appendFSStations(stations, fsVSNs):
	for f in fsVSNs:
		if f[0] not in stations:
			stations.append(f[0])
	stations.sort()

def processVexFile(vexFile, force, verbose, vsnProjectCode, fsVSNs=[]):
	if not isfile(vexFile):
		print 'Error: cannot open file %s' % vexFile
		exit(0)

	outFile = vexFile + '.obs'
	if isfile(outFile):
		if force:
			print 'Warning: overwriting old output because of --force option\n'
		else:
			print 'Error: destination file %s exists and I won\'t overwrite it!\n' % outFile
			exit(0)

	obsCode, obsSeg, stationTimes = vexPeek(vexFile, verbose)
	if obsCode == 'Error':
		print 'Not processing file %s; it is not present or valid.' % vexFile
		exit(0)

	experTimes = calcExperTimes(stationTimes)

	db = cx_Oracle.connect(databaseName)

	# fetch a bunch of stuff from the database
	shelves = getShelvesFromDB(db, verbose)
	if vsnProjectCode != None:
		c, s = splitobscode(vsnProjectCode)
		if verbose:
			print 'vsn project code and segment are', c, s
		tapes = getTapesFromDBbyTime(db, experTimes[0], experTimes[1], verbose)
		motions = getTapeMotionFromDB(db, c, s, verbose)
	else:
		tapes = getTapesFromDBbyTime(db, experTimes[0], experTimes[1], verbose)
		motions = getTapeMotionFromDB(db, obsCode, obsSeg, verbose)
	eops = getEarthFromDB(db, mjdCenter(stationTimes), verbose)

	vsns = makeVSNDict(tapes)

	vexData = open(vexFile, "r").readlines()

	vexData.append('*------------------------------------------------------------------------------\n')
	vexData.append('*---- log data below was appended by %s ver %s ----\n' % (program, version))
	vexData.append('*------------------------------------------------------------------------------\n')

	shelfData = []
	vexData.append('$TAPELOG_OBS;\n')

	stations = stationTimes.keys()
	stations.sort()

	for s in stations:
		stn = upper(s)
		scans = calcVSNList(motions, vsns, stn)
		blocks = genBlocks(scans, experTimes)
		if len(blocks) < 1:
			blocks = getBlocksFromFS(fsVSNs, Ulow(stn))
		if len(blocks) < 1:
			print 'Warning: No media found for station %s' % stn
			continue
		vexData.append('def %s;\n' % Ulow(stn))
		for b in blocks:
			b.append(getShelf(shelves, b[2]))
			vexData.append('  VSN = %d : %s : %s : %s;  * shelf = %s\n' % \
				((b[3]+1), b[2], mjd2vex(b[0]), mjd2vex(b[1]), b[4]))
			shelfData.append([stn, b[2], b[4]])
		vexData.append('enddef;\n')

	shelfFile = vexFile + '.shelf'
	if verbose > 0:
		print 'Writing to file: %s' % shelfFile
	writeShelfData(shelfData, shelfFile)

	vexData.append('*------------------------------------------------------------------------------\n')

	timeRange = [1.0e9, -1.0e9]
	for stn in stations:
		if timeRange[0] > stationTimes[stn][0]:
			timeRange[0] = stationTimes[stn][0]
		if timeRange[1] < stationTimes[stn][1]:
			timeRange[1] = stationTimes[stn][1]

	vexData.append('$CLOCK;\n')
	for stn in stations:
		last = (0.0, '', 0.0)
		clocks = getClockFromDB(db, stn, timeRange, verbose)
		if len(clocks) > 0:
			vexData.append('def %s;\n' % Ulow(stn));
			nClock = 0
			for c in clocks:
				if last != c[1:4]:
					data = signFlip(c)
					clockStart = data[1] + data[3]*(experTimes[0]-data[2])*86400.0
					clockEnd = data[1] + data[3]*(experTimes[1]-data[2])*86400.0
					vexData.append('  clock_early = %s : %10.8e sec : %s : %10.8e;  * offset = %4.2f usec\n' % (mjd2vex(data[0]), data[1], mjd2vex(data[2]), data[3], data[4]) )
					vexData.append('    * clock_start = %8.2f ns  clock_end = %8.2f ns\n' % (clockStart*1.0e9, clockEnd*1.0e9))
					last = c[1:4]
					nClock += 1
			vexData.append('enddef;\n')
			if nClock != 1:
				print 'Warning: %d clock entries for antenna %s' % (nClock, stn)
				print '  Please verify this is necessary and edit the .obs file as necessary'
		else:
			print 'Warning: No clock offset found for station %s' % stn
	vexData.append('*------------------------------------------------------------------------------\n')
	for e in eops:
		vexData.append(e)

	if verbose > 0:
		print 'Writing to file: %s' % outFile
	out = open(outFile, "w")
	for d in vexData:
		out.write(d)
	out.close()


# main below here

print ''

verbose = 0
force = False
stop = False
args = []
fsVSNs = [] # VSN list from field system logs
vsnProjectCode = None

for a in argv[1:]:
	if vsnProjectCode == '':
		vsnProjectCode = upper(a)
	elif a[0] == '-':
		if a in ['-h', '--help']:
			usage(argv[0])
		elif a in ['-v', '--verbose']:
			verbose += 1
		elif a in ['-f', '--force']:
			force = True
		elif a in ['--vsnProjectCode']:
			vsnProjectCode = ''
		else:
			print 'Error: unknown command line option: %s' % a
			stop = True
	else:
		args.append(a)

if vsnProjectCode == '':
	print 'Error: vsnProjectCode not specified'
	stop = True

if len(args) == 0:
	print 'Error: no input files given.'
	stop = True

for a in args[1:]:
	print 'Parsing Field System Log %s' % a
	parseFSLog(a, fsVSNs)

if stop:
	print '\nRun with -h for help information.\n'
	exit(0)

umask(02)

processVexFile(args[0], force, verbose, vsnProjectCode, fsVSNs)

print ''
