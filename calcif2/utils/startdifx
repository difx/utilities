#!/usr/bin/env python

#**************************************************************************
#   Copyright (C) 2008-2012 by Walter Brisken                             *
#                                                                         *
#   This program is free software; you can redistribute it and/or modify  *
#   it under the terms of the GNU General Public License as published by  *
#   the Free Software Foundation; either version 3 of the License, or     *
#   (at your option) any later version.                                   *
#                                                                         *
#   This program is distributed in the hope that it will be useful,       *
#   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#   GNU General Public License for more details.                          *
#                                                                         *
#   You should have received a copy of the GNU General Public License     *
#   along with this program; if not, write to the                         *
#   Free Software Foundation, Inc.,                                       *
#   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
#**************************************************************************
#===========================================================================
# SVN properties (DO NOT CHANGE)
#
# $Id$
# $HeadURL: $
# $LastChangedRevision$
# $Author$
# $LastChangedDate$
#
#============================================================================

PROGRAM = 'startdifx'
VERSION = '0.8'
VERDATE = '20120927'
AUTHOR  = 'Walter Brisken'

defaultgroup = "224.2.2.1"
defaultport  = 50200
defaultttl   = 3
maxGenmachineFail = -1

genmachines = 'genmachines -v'
calcif      = 'calcif2'
difx2fits   = 'difx2fits -v'
mpiOptions  = '--mca mpi_yield_when_idle 1 --mca rmaps seq'

from sys import argv, exit, stdout
from os import popen, getcwd, system, getenv, getpid, environ
from os.path import isfile, isdir
from string import split, strip, find, rfind, upper, lower
from time import time, asctime
from glob import glob
from copy import deepcopy
from xml.parsers import expat
import socket
import struct
import signal
import subprocess


verbose = 0

def usage():
	print '\n%s ver. %s  %s  %s\n' % (PROGRAM, VERSION, VERDATE, AUTHOR)
	print 'A program to simplify the launching of mpifxcorr, specialy tuned'
	print 'for NRAO-DiFX usage.  It can also cause model and FITS to be made.\n'
	print 'Usage: startdifx [options] [<start delay>] <input1> [<input2> [ ... ] ]\n'
	print 'options can include:\n'
	print '  -h or --help'
	print '          print this usage info and exit\n'
	print '  -v or --verbose'
	print '          be more verbose\n'
	print '  -q or --quiet'
	print '          be quieter\n'
	print '  -f or --force'
	print '          force running even if output file exists\n'
	print '  -a or --automachines'
	print '          will run genmachines if needed\n'
	print '  -g or --genmachines'
	print '          will run genmachines even if not needed [default]\n'
	print '  -n or --nomachines'
	print '          will not run genmachines, even if needed\n'
	print '  -d or --dont-calc'
	print '          will not run calcif, even if needed\n'
	print '  -D or --difxdb'
	print '          make use of difxdb\n'
	print '  -m or --message'
	print '          start difx via DifxStartMessage\n'
	print '  -F or --fits'
	print '          generate 1 fits file per job at end of each\n'
	print '  -l or --localhead'
	print '          use the current host as the head node\n'
	print '  --override-version'
	print '          ignore difx version differences\n'
	print '<start delay> is an optional delay (seconds) to add to the job start time\n'
	print '<inputN> is the file prefix for a DiFX input file (possibly including .input)\n'
	print 'Environment variables DIFX_MESSAGE_GROUP and DIFX_MESSAGE_PORT'
	print 'can be used to override the default group/port of %s/%d\n' % \
		(defaultgroup, defaultport)
	exit(0)


class Parser:

    def __init__(self):
        self._parser = expat.ParserCreate()
        self._parser.StartElementHandler = self.start
        self._parser.EndElementHandler = self.end
        self._parser.CharacterDataHandler = self.data
	self.message = ''
	self.mjd = 0.0
	self.state = ''
	self.tmp = ''
	self.ok = False
	self.unit = ''
	self.mpiId = -1
	self.id = ''
	self.tag = ''

    def feed(self, data):
        self._parser.Parse(data, 0)

    def close(self):
        self._parser.Parse("", 1) # end of data
        del self._parser # get rid of circular references

    def start(self, tag, attrs):
        self.tag = tag
        self.tmp = ''
        if tag == 'difxStatus':
                self.ok = True

    def end(self, tag):
        if tag == 'message' and self.ok:
		self.message = self.tmp
	elif tag == 'state':
		self.state = self.tmp
	elif tag == 'visibilityMJD':
		self.mjd = float(self.tmp)
	elif tag == 'from':
		self.unit = lower(self.tmp)
	elif tag == 'identifier':
		self.id = self.tmp
	elif tag == 'mpiProcessId':
		self.mpiId = int(self.tmp)

    def data(self, data):
        if self.tag == 'message':
            self.tmp = self.tmp + data	
        else:
            self.tmp = data

    def getInfo(self):
	if self.ok:
        	return 'MPI[%2d] %-9s %-12s %-7s %s' % (self.mpiId, self.unit, self.id, self.state, self.message)
	else:
		return ''

def watchJob(jobId):
	
	if verbose > 1:
		print 'Watching %s:' % jobId

	port = getenv('DIFX_MESSAGE_PORT')
	if port == None:
		print 'DIFX_MESSAGE_PORT needs to be defined'
		exit(0)
	else:
		port = int(port)
	group = getenv('DIFX_MESSAGE_GROUP')
	if group == None:
		print 'DIFX_MESSAGE_GROUP needs to be defined'
		exit(0)

	s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	s.bind(('', port))
	mreq = struct.pack("4sl", socket.inet_aton(group), socket.INADDR_ANY)
	s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

	try:
		while 1:
			try:
			    message = s.recv(1500)
			    if len(message) > 0 and message[0] == '<':
				p = Parser()
				p.feed(message)
				info = p.getInfo()
				p.close()
				if p.ok and p.id == jobId:
					if p.state == 'Running':
						if verbose > 0:
							stdout.write('.')
							stdout.flush()
					else:
						if verbose > 0:
							stdout.write("<%s>" % p.state)
							stdout.flush()
					if p.state == 'MpiDone' or p.state == 'Crashed':
						return
			except socket.timeout:
				pass
	except KeyboardInterrupt:
		pass


def updateEnvironment(filename):
	
	savedEnvironment = []
	
	if isfile(filename):
		lines = open(filename).readlines()
		for l in lines:
			if l[0] == '#':
				continue
			e = split(strip(l))
			if len(e) == 2:
				savedEnvironment.append([e[0], getenv(e[0])])
				environ[e[0]] = e[1]

	return savedEnvironment


def restoreEnvironment(savedEnvironment):

	for e in savedEnvironment:
		if e[1] == None:
			del environ[e[0]]
		else:
			environ[e[0]] = e[1]


def getjobdifxversion(fileBase):
	files = glob(fileBase+'.calc')
	if len(files) < 1:
		return None
	d = open(files[0]).readlines()
	for l in d:
		if l[:12] == 'DIFX VERSION':
			return strip(l[20:])

def testDifxVersion(fileBase, override):
	jobver = getjobdifxversion(fileBase)
	ver    = getenv('DIFX_VERSION')
	if ver == None:
		print 'Warning: env. var. DIFX_VERSION not defined!'
	if jobver == None:
		print 'Warning: %s.calc does not contain version info' %fileBase
	if ver != None and jobver != None and ver != jobver:
		print 'Warning: $DIFX_VERSION and job version mismatch'
		print '    <%s> != <%s>' % (ver, jobver)
		if override:
			print 'Continuing anyway due to --override-version'
		else:
			print 'Quitting since --override-version not specified'
			exit(0)
	return ver
	

def sendMessage(fileBase, state, statusmessage):
	group = getenv('DIFX_MESSAGE_GROUP')
	if group == None:
		group = defaultgroup
	
	port = getenv('DIFX_MESSAGE_PORT')
	if port == None:
		port = defaultport
	else:
		port = int(port)
		
	identifier = split(fileBase, '/')[-1]
	
	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
	sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, defaultttl)

	message = \
		"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" \
		"<difxMessage>" \
		  "<header>" \
		    "<from>%s</from>" \
		    "<mpiProcessId>-1</mpiProcessId>" \
		    "<identifier>%s</identifier>" \
		    "<type>DifxStatusMessage</type>" \
		  "</header>" \
		  "<body>" \
		    "<seqNumber>-1</seqNumber>" \
		    "<difxStatus>" \
		      "<state>%s</state>" \
		      "<message>%s</message>" \
		      "<visibilityMJD>0</visibilityMJD>" \
		    "</difxStatus>" \
		  "</body>" \
		"</difxMessage>\n" % \
		(socket.gethostname(), identifier, state, statusmessage)
	
	sock.sendto(message, (group, port) )


# getNodes depends on the particular assumptions made by genmachines
def getNodes(fileBase):
	threads = []
	machines = []
	datastreams = []
	processors = {}

	threadData = open(fileBase + '.threads').readlines()
	for t in threadData[1:]:
		threads.append(int(t))
	machineData = open(fileBase + '.machines').readlines()
	
	nDatastream = len(machineData) - len(threads) - 1

	for m in range(1, nDatastream+1):
		datastreams.append(split(strip(machineData[m]))[0])

	for m in range(1+nDatastream, len(machineData)):
		i = m - 1 - nDatastream
		t = threads[i]
		if processors.has_key(t):
			processors[t].append(split(strip(machineData[m]))[0])
		else:
			processors[t] = [(split(strip(machineData[m]))[0])]

	return datastreams, processors


def sendStartMessage(fileBase, difxVersion, localHeadNode, restartSeconds):
	inputFile = fileBase + '.input'

	group = getenv('DIFX_MESSAGE_GROUP')
	if group == None:
		group = defaultgroup
	
	port = getenv('DIFX_MESSAGE_PORT')
	if port == None:
		port = defaultport
	else:
		port = int(port)
		
	headNode = getenv('DIFX_HEAD_NODE')
	corrHeadNode = headNode
	if localHeadNode:
		corrHeadNode = socket.gethostname()

	identifier = split(fileBase, '/')[-1]
	
	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
	sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, defaultttl)

	dsList, pList = getNodes(fileBase)
	system("rm -f %s.machines" % fileBase)
	system("rm -f %s.threads" % fileBase)

	dataStreams = ""
	for d in dsList:
		dataStreams = dataStreams + d + " "
	dataStreams = dataStreams.strip()
	processors = ""
	pKeys = pList.keys()
	for p in pKeys:
		processors = processors + "<process threads=\"%s\" nodes=\"" % p
		for q in pList[p]:
			processors = processors + q + " "
		processors = processors.strip() + "\"/>"
	
	if restartSeconds > 0:
		restartOption = '<restartSeconds>%f</restartSeconds>' % restartSeconds
	else:
		restartOption = ''

	message = \
		"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" \
		"<difxMessage>" \
		  "<header>" \
		    "<from>startdifx</from>" \
		    "<to>%s</to>" \
		    "<mpiProcessId>-1</mpiProcessId>" \
		    "<identifier>%s</identifier>" \
		    "<type>DifxStart</type>" \
		  "</header>" \
		  "<body>" \
		    "<difxStart>" \
		      "<input>%s</input>" \
		      "<manager node=\"%s\"/>" \
		      "<datastream nodes=\"%s\"/>" \
		      "%s" \
		      "<difxVersion>%s</difxVersion>" \
		      "%s" \
		    "</difxStart>" \
		  "</body>" \
		"</difxMessage>\n" % \
		(headNode, identifier, inputFile, corrHeadNode, dataStreams, processors, difxVersion, restartOption)

	if verbose > 0:
		print "Sending: ", message

	sock.sendto(message, (group, port) )

	watchJob(split(fileBase, '/')[-1])

	print "\n"


# verify presence of .machines file
def doMachines(fileBase, machinesPolicy, cache):
	machinesFile = fileBase + '.machines'

	cmd = 'grep "FILE " %s.input' % fileBase
	files = popen(cmd, 'r').readlines()
	
	cmd = 'grep "CORE CONF FILENAME" %s.input' % fileBase
	f = popen(cmd, 'r').readlines()
	if len(f) == 1:
		threadsFile = strip(split(f[0], ':')[-1])
	else:
		threadsFile = fileBase + '.threads'

	if cache[2] == files:
		if verbose > 0:
			print 'Using cached machines/threads info'
		cmd = 'cp %s %s' % (cache[0], machinesFile);
		if verbose > 1:
			print 'Executing: %s' % cmd
		system(cmd)
		cmd = 'cp %s %s' % (cache[1], threadsFile);
		if verbose > 1:
			print 'Executing: %s' % cmd
		system(cmd)
	else:
		if machinesPolicy == 2:
			system('rm -f %s' % machinesFile)

		nFail = 0
		while not isfile(machinesFile):
			if machinesPolicy > 0:
				localHeadString = ""

				options = ""
				if difxdb:
					options += " -d "

				cmd = '%s %s %s.input' % (genmachines, options, fileBase)
				if verbose > 1:
					print 'Executing: %s' % cmd
				v = -1
				while v !=0 :
					v = subprocess.call(cmd, shell=True)
					# CTRL+C
					if v==8:
						exit(0)
				if not isfile(machinesFile):
					nFail += 1
					if nFail > maxGenmachineFail and maxGenmachineFail > 0:
						return 0
			else:
				return 0

	cache[0] = machinesFile
	cache[1] = threadsFile
	cache[2] = files

	return len(open(machinesFile).readlines())

def handler(signum, frame):
    print 'Signal handler called with signal', signum
    exit(0)

# Start difx with DifxStartMessage
def runMessage(fileBase, machinesPolicy, deletePolicy, makeModel, override, useLocalHead, machinesCache, restartSeconds):

	difxVersion = testDifxVersion(fileBase, override)

	identifier = split(fileBase, '/')[-1]

	if not isfile(fileBase+'.input'):
		return 'Error: input file %s.input not found' % fileBase
	
	if not isfile(fileBase+'.im'):
		if makeModel and isfile(fileBase+'.calc'):
			system('%s %s.calc' % (calcif, fileBase))
		else:
			return 'Error: model not available for %s' % fileBase
	
	if restartSeconds > 0:
		if not isdir(fileBase+'.difx'):
			print 'Warning: restartSeconds = %d and no existing output!' % restartSeconds
	elif isdir(fileBase+'.difx') or isfile(fileBase+'.difx'):
		if deletePolicy == 1:
			if verbose > 0:
				print 'Removing %s.difx' % fileBase
			sendMessage(fileBase, 'Info', 'Deleting %s.difx' % fileBase)
			system('rm -rf %s.difx' % fileBase)
		else:
			print 'Warning: output file %s.difx exists' % fileBase
			return 
	
	np = doMachines(fileBase, machinesPolicy, machinesCache)
	if np <= 0:
		return 'Error: %s.machines not found' % fileBase

	sendStartMessage(fileBase, difxVersion, useLocalHead, restartSeconds)

	return None

# Start difx directly with mpirun
def runDirect(fileBase, machinesPolicy, deletePolicy, makeModel, override, useLocalHead, machinesCache, restartSeconds):

	difxVersion = testDifxVersion(fileBase, override)

	identifier = split(fileBase, '/')[-1]

	out = popen('which mpifxcorr').readlines()
	if len(out) != 1:
		return 'Error: mpifxcorr not found'
	pgm = strip(out[0])

	if not isfile(fileBase+'.input'):
		return 'Error: input file %s.input not found' % fileBase
	
	if not isfile(fileBase+'.im'):
		if makeModel and isfile(fileBase+'.calc'):
			calcOptions = ""
			if override:
				calcOptions += "--override-version " 

			for i in range(verbose):
				calcOptions += "-v "

			system('%s %s %s.calc' % (calcif, calcOptions, fileBase))
		else:
			return 'Error: model not available for %s' % fileBase
	
	if restartSeconds > 0:
		if not isdir(fileBase+'.difx'):
			print 'Warning: restartSeconds = %d and no existing output!' % restartSeconds
	elif isdir(fileBase+'.difx') or isfile(fileBase+'.difx'):
		if deletePolicy == 1:
			if verbose > 0:
				print 'Removing %s.difx' % fileBase
			sendMessage(fileBase, 'Info', 'Deleting %s.difx' % fileBase)
			system('rm -rf %s.difx' % fileBase)
		else:
			print 'Warning: output file %s.difx exists' % fileBase
                        return
	
	np = doMachines(fileBase, machinesPolicy, machinesCache)
	if np <= 0:
		return 'Error: %s.machines not found' % fileBase

	# spawn a logger process that will quit once this script ends
	# this will quietly fail on systems without difxlog installed
	cmd = 'difxlog %s %s.difxlog 4 %d &' % (identifier, fileBase, getpid())
	if verbose > 1:
		print 'Executing: %s' % cmd
	system(cmd);

	if difxVersion == None:
		difxProgram = 'mpifxcorr'
	else:
		difxProgram = 'runmpifxcorr.' + difxVersion

	if restartSeconds > 0.0:
		restartOption = ' -r%f' % restartSeconds
	else:
		restartOption = ''

	cmd = 'mpirun -np %d --bynode --hostfile %s.machines %s  %s %s.input%s' % (np, fileBase, mpiOptions, difxProgram, fileBase, restartOption)

	sendMessage(fileBase, 'Spawning', 'Spawning %d processes' % np)
	if verbose > 0:
		print 'Executing: ', cmd
	t0 = time()
	system(cmd)
	t1 = time()
	if verbose > 0:
		print 'Elapsed time (s) =', t1-t0
	groupId = getenv('DIFX_GROUP_ID')
	if groupId != None:
		cmd = 'chown :%s %s.difx/*' % (groupId, fileBase)
		if verbose > 1:
			print 'Executing: %s' % cmd
		system(cmd)
		cmd = 'chmod g+w %s.difx/*' % fileBase
		if verbose > 1:
			print 'Executing: %s' % cmd
		system(cmd)
	sendMessage(fileBase, 'MpiDone', '')

	return None


def run(fileBase, machinesPolicy, deletePolicy, makeModel, override, useStartMessage, useLocalHead, machinesCache, restartSeconds):
	
	savedEnvironment = updateEnvironment(fileBase+'.input.env')
	if useStartMessage:
		rv = runMessage(fileBase, machinesPolicy, deletePolicy, makeModel, override, useLocalHead, machinesCache, restartSeconds)
	else:
		rv = runDirect(fileBase, machinesPolicy, deletePolicy, makeModel, override, useLocalHead, machinesCache, restartSeconds)
	restoreEnvironment(savedEnvironment)

	return rv


if len(argv) < 2:
	usage()

machinesPolicy = 2
deletePolicy = 0
makeModel = True
makeFits = False
difxdb = False
useLocalHead = False
restartSeconds = 0.0
fileBaseList = []
cwd = getcwd()
override = False
useStartMessage = False
machinesCache = ['','',['Nothing to see here']]

signal.signal(signal.SIGINT, handler)


for a in argv[1:]:
	if a[0] == '-':
		if a == '-h' or a == '--help':
			usage()
		elif a == '-g' or a == '--genmachines':
			machinesPolicy = 2
		elif a == '-a' or a == '--automachines':
			machinesPolicy = 1
		elif a == '-n' or a == '--nomachines':
			machinesPolicy = 0
		elif a == '-m' or a == '--message':
			useStartMessage = True
		elif a == '-f' or a == '--force':
			deletePolicy = 1
		elif a == '-d' or a == '--dont-calc':
			makeModel = False
		elif a == '-D' or a == '--difxdb':
			difxdb = True
		elif a == '-F' or a == '--fits':
			makeFits = True
		elif a == '-v' or a == '--verbose':
			verbose += 1
		elif a == '-q' or a == '--quiet':
			verbose -= 1
		elif a == '-l' or a == '--localhead':
			useLocalHead = True
		elif a == '--override-version':
			override = True
	else:
		try:
			restartSeconds = float(a)
		except:
			if a[-6:] == '.input':
				fb = a[:-6]
			else:
				fb = a
			if fb[0] == '/':
				fileBaseList.append(a)
			else:
				fileBaseList.append(cwd + '/' + fb)

if len(fileBaseList) < 1:
	usage()
	
for fileBase in fileBaseList:
	a = rfind(fileBase, "/")
	jobname = fileBase[a+1:]

	if len(jobname) > 31:
		sendMessage(fileBase, 'ABORTED', "Did not start job because jobname is too long!")
		print "Job name %s is too long and will be skipped!" % fileBase
		exit(1)

	v = run(fileBase, machinesPolicy, deletePolicy, makeModel, override, useStartMessage, 
		useLocalHead, machinesCache, restartSeconds)

	if v != None:
		sendMessage(fileBase, 'ABORTED', v)
		print v
		exit(1)
	elif makeFits == True:
		system('%s %s %s.FITS' % (difx2fits, fileBase, fileBase))
