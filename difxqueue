#!/usr/bin/env python
# -*- coding: utf-8 -*-

#===========================================================================
# SVN properties (DO NOT CHANGE)
#
# $Id$
# $HeadURL$
# $LastChangedRevision$
# $Author$
# $LastChangedDate$
#
#============================================================================

from optparse import OptionParser
from os import getenv, mkdir, system, umask, getcwd, remove, rmdir
from os.path import isfile, isdir
from difxdb import  DiFXDBMySQLConnection, DiFXDBExperimentAction, DiFXDBExperimentItem, DiFXDBQueueItem 
from difxdb import DiFXDBQueueAction, DiFXDBJobAction, DiFXDBStatusAction, DiFXDBPassTypeAction, DiFXDBPassAction
from difxfiles import JobList
from difxutil import splitObservationCode, makeObservationCode, mjd2vexTime
from string import lower, strip
from glob import glob
import sys 
# "main" starts here

program = 'difxqueue_new'
version = "0.2"
author  = 'Helge Rottmann'
verdate = '2011-05-03'

queueBaseDir = ""
passName = ""
options = None

clusterHorsepower = 0.24


def readDBOptionsFile():
	"""
	Read database connection parameters from a MySQL options file. If not specified otherwise by the -c command line argument,
	the options file will be searched under $DIFXROOT/conf/difxdb.cnf.
	Note: The options file mechanism will work only for MySQL database server.
	"""

	optionsFile = ""
	
	# if command line option -c was given, read the connection parameters from the 
	# file specified else use the default $DIFXROOT/conf/difxdb.cnf
	if (len(options.dbConf) > 0):

		optionsFile = options.dbConf
		

		optionsFile = options.dbConf
	else:
		# otherwise check if the default file exists
		difxRoot = getenv('DIFXROOT')
		if difxRoot == None :
			exitOnError("DIFXROOT environent not defined")

		optionsFile = difxRoot + "/conf/difxdb.cnf"
	
	# check that the file exists
	if not isfile(optionsFile):
		exitOnError("Database options file not found: %s" % optionsFile)

	return(optionsFile)
		

def setQueueDirectoryOwnership(queueDir):
	"""
	Recursively set group ownership of queueDir according to contents of the
	DIFX_GROUP_ID environment variable. If the variable has not been set
	do nothing.
	"""

	# check for DIFX_GROUP_ID
	groupId = getenv('DIFX_GROUP_ID')

	# change queue directory permission
	if groupId != None:
		cmd = 'chown -R :%s %s' % (groupId, queueDir)
		if verbose > 0:
			print 'Executing: %s' % cmd
		system(cmd)
	
def setQueueDirectory(experiment):
	"""
	Determines the queue staging directory by reading the DIFX_QUEUE_BASE environment and
	adding the experiment code 
	Alternatively, if the user directory was given via the command line option this directory is used instead.
	Finally the queue directory is created (if it doesn't exist) 

	Returns the full path name of the queue directory
	"""	

	# check if command line option has been set
	if options.queueDir == None:
		
		difxQueueBase = getenv('DIFX_QUEUE_BASE')
		if difxQueueBase == None and not options.dbOnly:
			exitOnError("No queue directory defined. Either use -q option or set DIFX_QUEUE_BASE")

		queueDir = difxQueueBase + '/' + str.lower(experiment)
	else:
		queueDir = options.queueDir

	if (options.verbose > 0):
		print "VERBOSE: Using queue directory: %s" % queueDir
	
	# make queue directory (if it doesn't exist yet)
	if not isdir(queueDir):
		cmd = 'mkdir -p %s' % queueDir
		if options.verbose > 0:
			print 'VERBOSE: Executing: %s' % cmd
		system(cmd)

		# check if directory was created successfully
		if not isdir(queueDir):
			exitOnError("Could not create directory: %s" % (queueDir))

		

	return(queueDir)

def processSetPassTypeAction(args):
	"""
	Change the type of one or more passes 
	This function is called when the user selects the "setpasstype" command
	Input:
		args: 		the command line arguments given by the user
	"""

	newType = ""
	passes = list()
	project = ""

	if len(args) < 3:
		parser.print_help()
		exit(0)

	newType = lower(args[1])
	project = args[2]

	if len (args) > 3:
		passes.extend(args[3:])

	# check that the requested type exists
	passTypeId = DiFXDBPassTypeAction.getTypeIDByName(dbConn, newType)
	if passTypeId == None:
		exitOnError("Unknown pass type '%s' requested" % newType)

	if not options.force:
		confirmAction("change pass type")

	passList = DiFXDBQueueAction.getPasses(dbConn, project, passes)

	# loop over all passes
	for Pass in passList:
		Pass.Pass.passTypeID = passTypeId
		DiFXDBPassAction.updatePass(dbConn, Pass.Pass)

		print "Changing pass type to %s on  %s / %s (Exp/Pass)" % (newType, project, Pass.Pass.passName)

	return

def processSetStateAction(args):
	"""
	Change the state of a job 
	This function is called when the user selects the "setstate" command
	Input:
		args: 		the command line arguments given by the user
	"""

	jobNumbers = []
	project = ""
	Pass = []

	

	if len(args) < 4:
		parser.print_help()
		exit(0)

	newStatus = lower(args[1])
	project = args[2]
	passName
	if len (args) > 3:
		Pass.append( args[3] ) 
	
	if len (args) > 4:
		jobNumbers = getnumbers(args[4:])

	queueList = DiFXDBQueueAction.getJobs(dbConn, project, Pass, jobNumbers)

	if len(queueList) == 0:
		print "No queued jobs matching your search criteria found"
		return

	jobStatusId = DiFXDBStatusAction.getStatusIDByName(dbConn, newStatus)

	# check that the requested status exists
	if jobStatusId == None:
		exitOnError("Unknown job status '%s' requested" % newStatus)

	if not options.force:
		confirmAction("change job state")

	for queue in queueList:
		print "Processing  %s / %s / %s (Exp/Pass/Number)" % (project, Pass[0], queue.Job.jobNumber)
		queue.Job.statusID = jobStatusId
		DiFXDBJobAction.updateJob(dbConn, queue.Job)
		
	
	return
	

def processDeleteAction(args):
	"""
	Delete jobs from the database and from the correlation staging area
	This function is called when the user selects the "delete" command
	Input:
		args: 		the command line arguments given by the user
	"""
	project = ""
	passes = []
	jobNumbers = []

	if len(args) < 2:
		parser.print_help()
		exit(0)

	project = args[1]

	if len(args) > 2:
		passes.append(args[2])

	if len(args) > 3:
		jobNumbers = getnumbers(args[3:])

	queueList = DiFXDBQueueAction.getIncompleteJobsByPasses(dbConn, project, passes)

	if len(queueList) == 0:
		print "No queued jobs matching your search criteria found"
		return

	# get user confirmation before doing the delete from the DB
	confirmAction ("delete")

	
	dontAsk = False

	for queue in queueList:

		queueDir = setQueueDirectory(lower(makeObservationCode(queue.Experiment.code, queue.Experiment.segment)))

		if len(jobNumbers) > 0 and queue.Job.jobNumber not in jobNumbers:
			continue

		sys.stdout.write("Processing  %s / %s / %s (Exp/Pass/Number)" % (makeObservationCode(queue.Experiment.code, queue.Experiment.segment), queue.Pass.passName, queue.Job.jobNumber))

		# skip file deletion if option dbonly was selected by the user
		if (not options.dbOnly):

			# check if output data exists for this job
			if isdir(queue.Job.inputFile[0:-6]+ '.difx' ):
				print '\nWarning: correlator output for job %d of pass %s exists.' % (queue.Job.jobNumber, queue.Pass.passName)

				
				if (not dontAsk):
					print 'Continue anyway, destroying this data? [y/N/a/c] (y=yes, n=no (default), a = all, c = cancel)'
					reply = strip(lower(sys.stdin.readline()))

					if reply == 'a':
						dontAsk = True
						reply = 'y'
						print 'Assuming yes for all remaining'
					elif reply == 'c':
						print 'Canceling'
						return;
			
				else:
					reply = 'y'

				if reply =='y':
					if (dontAsk):
						print 'Continuing anyway'
					else:
						print 'OK -- proceeding'
				else:
					continue
				
			# delete all files
			for filename in glob('%s.*' % queue.Job.inputFile[0:-6]):
				try:
					remove(filename)	
				except:
					print("\n")
					exitOnError("Could not delete file:%s" % (filename))

				
			sys.stdout.write("...deleted files")
			
			# delete directory if it contains no more files
			if len(glob('%s/*' % queueDir)) == 0:

				try:
					rmdir(queueDir)
				except:
					print("\n")
					exitOnError("Could not delete directory:%s" % (queueDir))
				

		# delete job from database
		DiFXDBQueueAction.deleteQueueItem(dbConn, queue)
		sys.stdout.write("...deleted from database\n")

	
def processPriorityAction(args, priorityInc):
	"""
	Increase or decrease the job priority.
	This function is called when the user selects the "bump" or "slide" commands
	Input:
		args: 		the command line arguments given by the user
		priorityInc:	the desired priority increment (decrement)
	"""

	project = ""
	passes = []
	jobNumbers = []

	if len(args) < 2:
		parser.print_help()
		exit(0)

	project = args[1]

	if len(args) > 2:
		passes.append(args[2])

	if len(args) > 3:
		jobNumbers = getnumbers(args[3:])


	queueList = DiFXDBQueueAction.getIncompleteJobsByPasses(dbConn, project, passes)

	if len(queueList) == 0:
		print "No queued jobs matching your search criteria found"
		return

	# get user confirmation before changing the priority
	if (priorityInc > 0):
		confirmAction ("bump")
	else:
		confirmAction ("slide")

	for queue in queueList:

		if len(jobNumbers) > 0 and queue.Job.jobNumber not in jobNumbers:
			continue
		
		queue.Job.priority += priorityInc
		DiFXDBJobAction.updateJob(dbConn, queue.Job)
		print "Set priority to %s on %s/%s/%s (Exp/Pass/Number)" % (queue.Job.priority, makeObservationCode(queue.Experiment.code, queue.Experiment.segment), queue.Pass.passName, queue.Job.jobNumber)

	

def processPrintQueueAction(args):
	

	projects = []
	for a in args[1:]:
		projects.append(a)

	totalDur = 0;
	totalCor = 0;

	formatTable = '%-10s%-10s %5d %3d %-10s%2d/%2d %-19s%4d %-8.1f  %-4.4f'
	formatHeader = '%-10s%-10s %5s %3s %-10s%5s %-19s%4s %-10s%-10s'

	queueList = DiFXDBQueueAction.getIncompleteJobs(dbConn , projects)

	if len(queueList) == 0:
		print "No queued jobs matching your search criteria found"
		return

	header = formatHeader % ('Exper', 'Pass', 'Num', 'Pri', 'Status', 'nAnt', 'Start', 'Dur', 'SpeedUp', "Total(hrs)")
	print header
	
	for queue in queueList:

		totalDur += queue.Job.jobDuration
		totalCor += queue.Job.jobDuration / queue.Job.speedupFactor

		line = formatTable % \
			(makeObservationCode(queue.Experiment.code, queue.Experiment.segment), queue.Pass.passName, queue.Job.jobNumber, \
			queue.Job.priority, queue.Job.status, queue.Job.numAntennas, queue.Job.numForeign, mjd2vexTime(queue.Job.jobStart),\
			queue.Job.jobDuration, queue.Job.speedupFactor, totalCor/3600)

		print line

	print 'Total observe time        = %4.2f hours' % (totalDur / 3600.0)
	print 'Total correlation time    = %4.2f hours' % (totalCor / 3600.0)

def readJobList(passName):

	print joblist.parameters
	print joblist.jobs[0]

def getnumbers(stringlist):
	"""
	Separates a range string (e.g. 1 3-5 10 12-18) and populates a
	list with the individual numbers
	"""
	numbers = []
	for s in stringlist:
		sepIndex = s.find("-")

		if sepIndex > 0:
			try:
				start = int(s[:sepIndex])
				stop = int(s[sepIndex+1:])
			except Exception, e:
				exitOnError(e)

			if stop < start:
				exitOnError("Illegal range of jobs given: start value exceeds stop value")
		else:
			try:
				start = stop = int(s)
			except Exception, e:
				exitOnError(e)
				

		for i in range (start, stop+1):
			if not i in numbers:
				numbers.append(i)
	numbers.sort()

	return numbers

def processAddAction(args):
	'''
	Adds one or more job to the database and copies job files to the correlation staging area.
	'''

	global queueDir

	queueDir = ""
	jobNumbers =[]

	if len(args) < 2:
		parser.print_help()
		exit(0)

	passName = args[1]
	if passName[-8:] == '.joblist':
		jobListFile = passName
	else:
		jobListFile = passName + '.joblist' 

	if len(args) > 2:
		jobNumbers = getnumbers(args[2:])

	try:
		joblist = JobList(".", jobListFile)
	except IOError, ex:
		exitOnError (ex)
		
	OK = True
	for job in joblist.getJobs(jobNumbers):
		OK &= job.validate(preCorr=True)

	if not OK:
		exitOnError('one or more jobs failed validation')
	
	queueDir = setQueueDirectory(lower(joblist.parameters["exper"]))

		
	# check if any jobs (=identical input files) have already been queued and are active
	badList = []
	activeList = DiFXDBQueueAction.getActiveJobs(dbConn)

	for job in joblist.getJobs(jobNumbers):
		for activeJob in activeList:
			if activeJob.Job.inputFile == queueDir + "/" + job.name + ".input":
				badList.append(queueDir + "/" + job.name)
				
	if len(badList) > 0:
		print '\nThe following jobs are already in the queue:'
		for badJob in badList:
			print '  %s' % badJob
		print 'Please rerun, including only those jobs not already queued.'
		return

	# adding jobs to the database			
	for job in joblist.getJobs(jobNumbers):
		
		sys.stdout.write("Processing %s ..." % job.name)
		queueItem = DiFXDBQueueItem()
		(code, segment) = splitObservationCode(joblist.parameters["exper"])
		queueItem.Experiment.code = code
		queueItem.Experiment.segment = segment
		queueItem.Pass.passName = joblist.parameters["pass"]
		queueItem.Pass.passType = options.passType
		queueItem.Job.jobNumber = job.number
		queueItem.Job.jobStart = job.mjdStart
		queueItem.Job.jobDuration = (job.mjdStop - job.mjdStart)  * 86400.0
		queueItem.Job.inputFile = queueDir + "/" + job.name + ".input"
		queueItem.Job.difxVersion = joblist.parameters["DiFX"]
		queueItem.Job.numAntennas = job.nAnt
		queueItem.Job.numForeign = job.nNonVLBAAntennas
		queueItem.Job.priority = options.priority
		queueItem.Job.speedupFactor = ((job.mjdStop - job.mjdStart)  * 86400.0) / job.computationalLoad * clusterHorsepower;
		
		
		
		# add job to the database
		try:
			DiFXDBQueueAction.addQueueItem(dbConn, queueItem)
		except Exception, e:
			exitOnError(e)
		else:
			sys.stdout.write("... added to database" )

		
		# copy file
		if not options.dbOnly:

			# build options for running difxcopy and calcif2
			optStr = ""
			for i in range(0, options.verbose):
				optStr += "-v "
			# if this script was started in the queue directory skip copying files
			if(queueDir != getcwd()):
				cmd = 'difxcopy %s %s %s' % (optStr, job.name, queueDir)
				if options.verbose > 0:
					print 'VERBOSE: Executing: %s' % cmd
				system(cmd)
				sys.stdout.write("...copied to the queue directory")
			else:
				sys.stdout.write("...not copied -- using local directory")

			# run calcif2
			if options.overrideVersion:
				optStr += " --override-version "
			cmd = 'calcif2 %s -f %s/%s' % (optStr, queueDir, job.name)
			if options.verbose > 0:
				print 'VERBOSE: Executing: %s' % cmd
			system(cmd)
			sys.stdout.write("...ran calcif2")


		print ("...done")

	# change group ownership
	setQueueDirectoryOwnership(queueDir)
	
	
def processProdAction(args):
		
	return

def confirmAction(action):
	"""
	Get user confirmation before executing commands
	"""
	
	# if --force option was used skip confirmation
	if (options.force):
		return

	print '\nThe %s action is about to be applied to all matching jobs' %\
		action
	print '\nAre you sure you want to proceed? [y/N]'

	a = lower(sys.stdin.readline())
	if strip(a) == 'y':
		print 'OK -- proceeding\n'
	else:
		print 'Not continuing.\n'
		exit(0)

def exitOnError(exception):
	'''
	Exit routine to be called whenever an error/exception has occured
	'''
	print "ERROR: %s. Aborting" % exception
	
	exit(1)

def getUsage():

	usage=  '\n%s ver %s  %s  %s' % (program, version, author, verdate)
	usage += '\nA program to send DiFX jobs to the correlator queue and update the database.'
	usage += '\nFunctionality to examine and modify the contents of the queue are also provided.\n'
	
	usage += "\nUsage: %prog [options] <command> [<args>]\n"

	usage += "\nCommands: \n"

	usage += "add	Add job(s) to the queue\n"
	usage += "\targuments = <pass name> [list of job numbers]\n"
	usage += "\texample 1:   difxqueue add clock\n"
	usage += "\texample 2:   difxqueue add geodesy 3 4-9 12\n"

	usage += "delete Delete job(s) from the queue\n"
	usage += "\targuments = <pass name> [list of job numbers]\n"
	usage += "\texample 1:   difxqueue delete clock\n"
	usage += "\texample 2:   difxqueue delete geodesy 3 4-9 12\n"

	usage += "printQueue Lists the jobs currently queued for processing.\n"
	usage += "\targuments = [list of experiments]\n"
	usage += "\texample 1:   difxqueue printQueue \n"
	usage += "\texample 2:   difxqueue printQueue r1455 r1456\n"

	usage += "bump	Increase the priority of job(s) by 1\n"
	usage += "\targuments = <experiment> [<pass name>] [list of job numbers]\n"
	usage += "\texample 1:   difxqueue bump r1455\n"
	usage += "\texample 2:   difxqueue bump r1455 clock \n"
	usage += "\texample 3:   difxqueue bump r1455 clock  3 4-9 12\n"

	usage += "slide	Decrease the priority of job(s) by 1\n"
	usage += "\targuments = <experiment> [<pass name>] [list of job numbers]\n"
	usage += "\texample 1:   difxqueue slide r1455\n"
	usage += "\texample 2:   difxqueue slide r1455 clock \n"
	usage += "\texample 3:   difxqueue slide r1455 clock  3 4-9 12\n"

	usage += "setState Change the state of job(s)\n"
	usage += "\targuments = <state> <experiment> [<pass name>] [list of job numbers]\n"
	usage += "\texample 1:   difxqueue setState complete r1455\n"
	usage += "\texample 2:   difxqueue setState queued r1455 clock \n"
	usage += "\texample 3:   difxqueue setState killed r1455 test  3 4-9 12\n"

	usage += "setPassType Change type of pass(es)\n"
	usage += "\targuments = <type> <experiment> [list of passes] \n"
	usage += "\texample 1:   difxqueue setPassType production r1455\n"
	usage += "\texample 2:   difxqueue setPassType production r1455 clock test \n"
	return usage

	
umask(02)

usage = getUsage()

parser = OptionParser(version="%prog " + version, usage=usage)

parser.add_option("-v", "--verbose", dest="verbose", action="count", default = 0, help="Send more output to the screen  (use -v -v for extra info)")
parser.add_option("-o", "--override-version", dest="overrideVersion", action="store_true", help="Force operation with mixed DiFX versions")
parser.add_option("-p", "--priority", dest="priority", type="int" , default = 0, help="Set the priority of the job to <PRIORITY> when adding to the queue")
parser.add_option("-d", "--db-only", dest="dbOnly", action="store_true", help="Operate only on database (some commands only)")
parser.add_option("-q", "--queuedir", dest="queueDir", type="string" ,action="store", help="Specify the directory to use as the correlation base (overrides DIFX_QUEUE_BASE environment)")
parser.add_option("-t", "--type", dest="passType", type="string" ,action="store", default="production", help="Specify the type of the jobs when adding to the queue")
parser.add_option("-f", "--force", dest="force" ,action="store_true", default=False, help="Perform actions on multiple files without confirmation ")
parser.add_option("-c", "--conf", dest="dbConf", type="string", default= "", help="Specify the option file that contains the database connection parameters (default: $DIFXROOT/conf/difxdb.cnf)")


# parse the command line. Options will be stored in the options list. Leftover arguments will be stored in the args list
(options, args) = parser.parse_args()

if (options.verbose > 0):
	print "Using options:"
	for key, value in options.__dict__.items():
		print "%s  : %s" % ( key, value)
	
if len(args) == 0:
	parser.print_help()
	exit(0)


optionsFile = readDBOptionsFile()

# open database connection
try:
	dbConn = DiFXDBMySQLConnection( user="bla", conf=optionsFile, verbosity=options.verbose)
except Exception, e:
	exitOnError(e)


action = lower(args[0])

if action == 'printqueue':
	processPrintQueueAction(args)

elif action == 'prod':
	print 'prod'
	processProdAction(args)
elif action == 'add':
	processAddAction(args)
elif action == 'bump':
	processPriorityAction(args, +1)
elif action == 'slide':
	processPriorityAction(args, -1)
elif action == 'delete':
	processDeleteAction(args)
elif action == 'setstate':
	processSetStateAction(args)
elif action == 'setpasstype':
	processSetPassTypeAction(args)
else:
	parser.print_help()
	exit(0)


# close the database connection
dbConn.close()
